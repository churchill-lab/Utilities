################################################################################
# Given annotation and expression for a set of genes and their genoprobs and
# kinship matrices, regress the gene expression of each gene on the genoprobs
# at the marker closest to the gene start.
#
# Arguments:
# expr: numeric matrix containing expression data. Samples in rows, genes in
#       columns. Sample IDs must be in rownames and Ensembl IDs must be in 
#       colnames. Sample IDs must match genoprobs, covar and K.
# genoprobs: list of numeric 3D arrays containing the allele probabilities for
#            each sample at each marker. In qtl2 format. For each list element,
#            samples are in rows, 8 founders in columns and markers in slices.
#            All dimensions must have dimnames. Produced by probs_doqtl_to_qtl2()
#            or genoprob_to_alleleprob().
# K: list of numeric matrices, one for each chormosome. Generated by 
#    calc_kinship with tyep = "loco". Sample IDs must be in rownames and
#    colnames of each matrix.
# covar: numeric matrix of additive QTL covariates. Do not include the intercept.
#        Typically made using model.matrix().
# map: list of numeric vectors containing the marker locations. Each vector
#      must be named with marker IDs that match the marker IDs in genoprobs.
# annot: data.frame containing gene annotation. column names msut be:
#        ensembl: Ensembl gene ID, character,
#        symbol: Gene symbol, character,
#        chr: gene chromosome, character (not factor!),
#        start: gene start position in Mb, numeric,
#        end: gene end positoin in Mb, numeric,
#        strand: gene strand at + or -, character,
#        Optional. If not provided, Bioconductor package AnnotationHub is 
#        loaded and the most recent Ensembl GTF is used. 
# ncores: integer that is greater than 0 indicating the number of cores to use
#         in parallel processing.
#
#
# Returns: Numeric vector with a LOD score for each gene.
#
# Daniel Gatti
# dan.gatti@jax.org
# Mar. 9, 2018
################################################################################
library(BiocParallel)
library(qtl2)

synch_samples = function(ex, gp, k, cv) {

  samples = intersect(rownames(ex), rownames(gp[[1]]))
  samples = intersect(samples, rownames(cv))

  message(paste("Found", length(samples), "samples in common."))

  ex = ex[samples,]
  cv = cv[samples,]
  for(i in 1:length(genoprobs)) {

    gp[[i]] = gp[[i]][samples,,]
    k[[i]]  = k[[i]][samples, samples]

  } # for(i)

  return(list(expr = ex, genoprobs = gp, K = k, covar = cv))

} # synch_samples()


synch_markers = function(gp, mp) {

  for(i in 1:length(gp)) {

    mkrs = intersect(dimnames(gp[[i]])[[3]], names(mp[[i]]))
    gp[[i]] = gp[[i]][,,mkrs]
    mp[[i]] = mp[[i]][mkrs]

  } # for(i)

  message(paste("Found", sum(sapply(map, length)), "markers in common."))

  return(list(genoprobs = gp, map = mp))

} # synch_markers()


synch_genes = function(ex, an) {

  genes = intersect(colnames(ex), an$ensembl)

  message(paste("Found", length(genes), "genes in common."))

  ex = ex[,genes]
  an = an[match(genes, an$ensembl),]

  return(list(expr = ex, annot = an))

} # synch_samples()


cis_eqtl_engine = function(expr, genoprobs, K, covar, annot, map, ncores = 1) {

  tmp = synch_samples(ex = expr, gp = genoprobs, k = K, cv = covar)
  expr      = tmp$expr
  genoprobs = tmp$genoprobs
  K         = tmp$K
  covar     = tmp$covar

  tmp = synch_markers(gp = genoprobs, mp = map)
  genoprobs = tmp$genoprobs
  map       = tmp$map

  rm(tmp)
  gc()

  # If the user did not provide gene annotation, then get it from Ensembl.
  # Use the latest build.
  if(missing(annot)) {

    library(AnnotationHub)
    hub = AnnotationHub()
    hub = query(hub, c("ensembl", "mus musculus", "gtf"))
    hub = hub[grep("^Mus_musculus\\.GRCm38\\.[0-9]+\\.chr\\.gtf$", hub$title)]
    message(paste("Using Ensembl file:", hub$title[length(hub)]))
    ensembl = hub[[names(hub)[length(hub)]]]
    ensembl = ensembl[ensembl$type == "gene"]
    annot = data.frame(ensembl = ensembl$gene_id,
                       symbol  = ensembl$gene_name,
                       chr     = as.character(seqnames(ensembl)), 
                       start   = start(ensembl) * 1e-6, 
                       end     = end(ensembl) * 1e-6,
                       strand  = strand(ensembl),
                       stringsAsFactors = FALSE)
    annot = annot[match(colnames(expr), annot$ensembl),]

  } # if(missing(annot))

  # Remove genes that are not on Chr 1:19 & X.
  annot = annot[annot$chr %in% c(1:19, "X"),]
  
  tmp = synch_genes(ex = expr, an = annot)
  expr  = tmp$expr
  annot = tmp$annot

  # Run in parallel if ncores > 1.
  bpparam = MulticoreParam(workers = ncores, progressbar = TRUE, log = TRUE,
            logdir = ".")

  # Internal function to perform cis_eqtl mapping.
  # gene_id: Ensembl Id to map at gene start location.
  cis_fxn = function(gene_id) {

    print(gene_id)
    annot = annot[annot$ensembl == gene_id,]
    chr   = annot$chr[1]
    pos   = annot$start[1]

    g = genoprobs[,chr]
    k = K[chr]
    m = map[[chr]]
    mkr = names(m)[which.min(abs(m - pos))]
    g[[1]] = g[[1]][,,mkr,drop = FALSE]
 
    return(scan1(genoprobs = g, pheno = expr[,gene_id], kinship = k, addcovar = covar))

  } # cis_fxn()

  qtl = bplapply(annot$ensembl, cis_fxn, BPPARAM = bpparam)

  return(qtl)

} # cis_eqtl_engine()

